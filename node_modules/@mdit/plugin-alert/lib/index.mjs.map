{"version":3,"file":"index.mjs","sources":["../src/plugins.ts"],"sourcesContent":["import { type PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.js\";\nimport { type RuleBlock } from \"markdown-it/lib/parser_block.js\";\n\nimport { MarkdownItAlertOptions } from \"./options\";\n\nconst HINT_REGEXP = /^>(?:(?: {0,3})| {0,2}\\t {0,1})\\[!(.*)\\]\\s*$/i;\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  const alertRule: RuleBlock = (state, startLine, endLine, silent) => {\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) return false;\n\n    // check whether it's at first level\n    if (state.level !== 0 && !deep) return false;\n\n    const pos = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n\n    // check the block quote marker\n    if (state.src.charAt(pos) !== \">\") return false;\n\n    // check alert markers\n    const match = HINT_REGEXP.exec(state.src.slice(pos, max));\n\n    if (!match || !alertNames.includes(match[1].toLowerCase())) return false;\n\n    // we know that it's going to be a valid alert,\n    // so no point trying to find the end of it in silent mode\n    if (silent) return true;\n\n    const type = match[1].toLowerCase();\n    const oldBMarks = [];\n    const oldBSCount = [];\n    const oldSCount = [];\n    const oldTShift = [];\n    const oldLineMax = state.lineMax;\n    const oldParentType = state.parentType;\n    const terminatorRules = state.md.block.ruler.getRules(\"alert\");\n\n    // @ts-expect-error\n    state.parentType = \"alert\";\n\n    // Search the end of the block\n    //\n    // Block ends with either:\n    //  1. an empty line outside:\n    //     ```\n    //     > test\n    //\n    //     ```\n    //  2. an empty line inside:\n    //     ```\n    //     >\n    //     test\n    //     ```\n    //  3. another tag:\n    //     ```\n    //     > test\n    //      - - -\n    //     ```\n    let nextLine;\n\n    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n      let adjustTab = false;\n      let lastLineEmpty = false;\n      let pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      const max = state.eMarks[nextLine];\n\n      // check if it's outdented, i.e. it's inside list item and indented\n      // less than said list item:\n      //\n      // ```\n      // 1. anything\n      //    > current blockquote\n      // 2. checking this line\n      // ```\n      const isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n      if (pos >= max)\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        break;\n\n      if (state.src.charCodeAt(pos++) === 0x3e /* > */ && !isOutdented) {\n        let spaceAfterMarker: boolean;\n        // This line is inside the blockquote.\n\n        // set offset past spaces and \">\"\n        let initial = state.sCount[nextLine] + 1;\n\n        // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          adjustTab = false;\n          spaceAfterMarker = true;\n        } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n          spaceAfterMarker = true;\n\n          if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n            adjustTab = false;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        } else {\n          spaceAfterMarker = false;\n        }\n\n        let offset = initial;\n\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n\n        while (pos < max) {\n          const ch = state.src.charCodeAt(pos);\n\n          if (isSpace(ch))\n            if (ch === 0x09)\n              offset +=\n                4 -\n                ((offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4);\n            else offset++;\n          else break;\n\n          pos++;\n        }\n\n        lastLineEmpty = pos >= max;\n\n        oldBSCount.push(state.bsCount[nextLine]);\n        state.bsCount[nextLine] =\n          state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] = offset - initial;\n\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      }\n\n      // Case 2: line is not inside the blockquote, and the last line was empty.\n      if (lastLineEmpty) break;\n\n      // Case 3: another tag found.\n      let terminate = false;\n\n      for (let i = 0; i < terminatorRules.length; i++)\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n\n      if (terminate) {\n        // Quirk to enforce \"hard termination mode\" for paragraphs;\n        // normally if you call `tokenize(state, startLine, nextLine)`,\n        // paragraphs will look below nextLine for paragraph continuation,\n        // but if blockquote is terminated by another tag, they shouldn't\n        state.lineMax = nextLine;\n\n        if (state.blkIndent !== 0) {\n          // state.blkIndent was non-zero, we now set it to zero,\n          // so we need to re-calculate all offsets to appear as\n          // if indent wasn't changed\n          oldBMarks.push(state.bMarks[nextLine]);\n          oldBSCount.push(state.bsCount[nextLine]);\n          oldTShift.push(state.tShift[nextLine]);\n          oldSCount.push(state.sCount[nextLine]);\n          state.sCount[nextLine] -= state.blkIndent;\n        }\n\n        break;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      oldBSCount.push(state.bsCount[nextLine]);\n      oldTShift.push(state.tShift[nextLine]);\n      oldSCount.push(state.sCount[nextLine]);\n\n      // A negative indentation means that this is a paragraph continuation\n      //\n      state.sCount[nextLine] = -1;\n    }\n\n    const oldIndent = state.blkIndent;\n\n    state.blkIndent = 0;\n\n    const titleLines: [number, number] = [startLine, startLine + 1];\n    const contentLines: [number, number] = [startLine + 1, 0];\n\n    const openToken = state.push(\"alert_open\", \"div\", 1);\n\n    openToken.markup = type;\n    openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n    openToken.map = contentLines;\n\n    const titleToken = state.push(\"alert_title\", \"\", 0);\n\n    titleToken.attrJoin(\"class\", `markdown-alert-title`);\n    titleToken.markup = type;\n    titleToken.content = match[1];\n    titleToken.map = titleLines;\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n    closeToken.markup = type;\n\n    state.lineMax = oldLineMax;\n    state.parentType = oldParentType;\n    contentLines[1] = state.line;\n\n    // Restore original tShift; this might not be necessary since the parser\n    // has already been here, but just to make sure we can do that.\n    for (let i = 0; i < oldTShift.length; i++) {\n      state.bMarks[i + startLine] = oldBMarks[i];\n      state.tShift[i + startLine] = oldTShift[i];\n      state.sCount[i + startLine] = oldSCount[i];\n      state.bsCount[i + startLine] = oldBSCount[i];\n    }\n    state.blkIndent = oldIndent;\n\n    return true;\n  };\n\n  md.block.ruler.before(\"blockquote\", \"alert\", alertRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  if (openRender) md.renderer.rules[\"alert_open\"] = openRender;\n\n  if (closeRender) md.renderer.rules[\"alert_close\"] = closeRender;\n\n  md.renderer.rules[\"alert_title\"] =\n    titleRender ||\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() +\n        token.content.substring(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],"names":["HINT_REGEXP","alert","md","alertNames","deep","openRender","closeRender","titleRender","alertRule","state","startLine","endLine","silent","pos","max","match","type","oldBMarks","oldBSCount","oldSCount","oldTShift","oldLineMax","oldParentType","terminatorRules","nextLine","adjustTab","lastLineEmpty","isOutdented","spaceAfterMarker","initial","offset","ch","isSpace","terminate","i","oldIndent","titleLines","contentLines","openToken","titleToken","closeToken","tokens","index","token"],"mappings":"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"}